ЛК 1 Операционная система

Архитектура фон Неймана
Команды и данные хранятся в памяти (ушли от перфокарт)
Память состоит из пронумерованных ячеек. Процессор имеет доступ к любой ячейке памяти по её адресу.
Программа - последовательность команд. Команды выполняются одна за другой
Последовательность может быть изменена определенными командами безусловно
Последовательность выполнения команд может быть изменена при анализе результатов выполнения предыдущих команд
![image](https://user-images.githubusercontent.com/97594483/213094568-de837dea-fb28-46fb-969f-cc334c00e217.png)

ЭВМ 2го покление
Первые языки программирования.

Переход на транзисторы
Плюсы:
 + Нет тепла нет перегорания -> Надёжность
 + Маленький размер, большая компановка -> Уменьшение ЭВМ
 Недостатки:
 - Сложная диагностика
 - Дорогое производство
 
 Упрощение процесса разработки
  - Появление алгоритмических языков (COBOL, ALGOL) / Появление компиляторов -> Появились программисты
  - Пакетная обработка заданий 
 
 ЭВМ 3-4го поколения
 Интегральые схемы 3-го поколения
 Большие схемы 1 000 000
 Плюсы интегральных схем:
  + Автоматизация производства -> Уменьшение стоимости
 
 Поколение 4-го поколения решает многозадачность, принцип мульти программирования и разделения времени
 Появление виртуальная память(появлаяется та часть программы, которая требуется для выполнения)
 Появление концепции баз данных для хранения больших объемов информации
 Вместо перфокарт пришли магнитные ленты и магнитные диски.
 Появление Apple I
 Появление Unix - 32-ух разрядная ОС
 Самописная файловая система утилита и систем
 
 Linux
 В 80-е - в ней появляется стек протоколов TCP/IP(Транспортный сетевой протокол передачи данных)
 Этот протокол определил, что информация лробиться на покеты, у каждого из которых есть IP или уникальный номер, что позволяет отслеживать их передачу.
 1991г. - GNU (бесплатные утилиты: gcc, bash) и Таненбаум
 Системные вызовы Unix
 Монолитное ядро
 Функции операционной системы
 1. Обеспечение выполнение программ
      - Выделение процессороного времени
      - Выделение памяти, загрузка в память исполнянмой программы
      - Обработка системных вызовов
      - Ввод и вывод данных
 2. Управление памятью системы (выделение памяти, освобождение памяти)
 3. Организация доступа к устройствам посредством файловых систем
 4. Стандартизованный доступ к устройствам ввода-вывода 
 5. Обеспечение безопасности
 6. Организация сетевого стека
 ![image](https://user-images.githubusercontent.com/97594483/213101282-7fef1d70-7b81-45b8-bc0a-065b888c7750.png)
 ![image](https://user-images.githubusercontent.com/97594483/213101275-dafb791f-2880-4cb0-a930-88f87b6956c9.png)
 
 Совместимость ОС
 Двоичная
 Приложение, скомпилированное для одной OC, можно запустить без перекомпиляции на другой OC
 На уровне исходных кодов 
 Один и тот же исходнаый код может быть скомпилирован в исполняемый модуль без изменений
 (передается файл схода)
 ![image](https://user-images.githubusercontent.com/97594483/213102102-0cf5bc4c-3f5a-4414-9a30-60b580dd465b.png)

 В Unix всё(клавиатура, ворды) файлы
 Основные типы файлов в Unix-like системах:
 1. Символьные устройства
 2. Блочные усройства
 3. Каталоги
 4. Ссылки
 5. Именованные каналы
 6. Сокеты
 ![image](https://user-images.githubusercontent.com/97594483/214491790-a8ba024d-aae6-48a4-af33-fdfe3a505a67.png)

 ![image](https://user-images.githubusercontent.com/97594483/214491733-d827d9af-2fdf-40cf-90cb-5107320401b8.png)
 
 Задание №1
 ![image](https://user-images.githubusercontent.com/97594483/215020286-0b283073-1b7a-4915-bc03-f0d3c70e52bb.png)

 
 Задание №2
 Работа с файлами
 
 Операции:
 Создание
 Редактирование
 Чтение
 Удаление
 Текстовый файл
 ![image](https://user-images.githubusercontent.com/97594483/214492997-1cb964fa-3abc-4951-9e62-11345488e06d.png)
 Директория
 ![image](https://user-images.githubusercontent.com/97594483/214497146-1fb200d9-bf81-4de1-bf2b-379a9f9352fa.png)
 “l” symlink символическая ссылка
![image](https://user-images.githubusercontent.com/97594483/214498077-b8cfbdf1-c013-47b0-834c-2d3afde9bc0f.png)
“s” unix sockets файл локального сокета.
![image](https://user-images.githubusercontent.com/97594483/220552665-94c0be24-820e-4a8d-acb6-f24cafeac000.png)
“p” pipe именованный канал
![image](https://user-images.githubusercontent.com/97594483/220553254-d722b712-54c0-42ee-8f1f-d3ab7fac3ce3.png)
“b” block device файл блочного устройства (sudo su)
![image](https://user-images.githubusercontent.com/97594483/220554756-a6c3ab46-b38d-4063-ac36-fdfc9e56db08.png)
“c” chat device файл символьного устройства 
![image](https://user-images.githubusercontent.com/97594483/220555594-cd246cbc-fd09-4aed-beaf-fc8d6dd3cb1b.png)




Перенаправление ввода
Обычный ввод - с клавиатуры. 
command < filename
 $cat < in_exemple_1
 $ ./input2.sh < in_example_1 &
 
command > filename - rewrite(переписывает)
command 1 > filename
command >> filename - append (добовляет)
 $ cat > out_file
 $ cat file1 file2 > resault_file
 $ ./input2.sh > out
 $ grep DHCP /var/log/syslog > dhcp_syslog.log
 
 2 > /dev/null - заглушает поток ошибок
 
   Процессы и потоки
Процесс - абстрактный термин
- память
- открытие файловые дескрипторы
- контекст выполнения
- pid
- обрабочики сигналов
- как минимум, один поток
Потоки имеют 
- общую виртуальную память
- каждый - свой виртуальный процессор
![image](https://user-images.githubusercontent.com/97594483/217463255-8889ed16-4eaf-4d4c-9d28-c7702a4ffd82.png)

PID - уникальный индентификато
PPID - ротеоь адремации областей памяти процеса
fd - файловый дескриптор
- код выхода
- -рабочий каталог
- переменные окружения
- состояние процесса
- аппаратный контекст

Жизненный цикл процесса
init - создание процесса
fork - копирование процесса
После вызова fork() есть дочерний и родительский процесс
Дочернему процессу (fork() возвращается 0, родительскому - PID
copy-on-write - адресное пространство родителя и породенного процесса совместно
Смерть процесса - kill
 

 
